---
title: "Getting started with geospatial coding in R using the terra and sf packages"
author: "Jason Flower"
date: "`r Sys.Date()`"
toc: true
number-sections: false
format: 
  html:
    self-contained: true
    code-tools: true
    df-print: paged
    fig-width: 6
abstract: |
  This is the first session of the ICCB workshop titled "Open Source Geospatial Tools for Conservation under Climate Change - a Koala Case Study". We will provide an introduction to working with geospatial in R using the sf and terra packages.
---

No prior experience of spatial data is assumed, but this introduction will not have time to delve deeply into some important aspects of spatial data such as projections. We will use the two most commonly used R packages for geospatial data manipulation: `sf` for manipulating vector data, and `terra` for manipulating raster and vector data. If you are still using the `raster` package, you should move to `terra`; it is simpler, faster and can do more!

*Resources*:

- The official `terra` [tutorial page](https://rspatial.org/spatial/index.html), and [reference](https://rspatial.github.io/terra/reference/terra-package.html) to all the `terra` functions
- The official `sf` [website](https://r-spatial.github.io/sf/) with a wealth of tutorials, function documentation, and further links
- The excellent Geocomputation with R [book](https://r.geocompx.org) which uses both `sf` and `terra`
- [This website](https://mgimond.github.io/Spatial/index.html) is a good guide to doing GIS work in R using both `terra` and `sf` packages

## Prerequisites 

You will need the `terra` and `sf` packages installed. We will also make an interactive map with `terra`, which requires the `leaflet` package to be installed, and we will need the `dplyr` package for data manipulation. 

```{r}
#| eval: false

install.packages(c("sf", "terra", "leaflet", "dplyr"))
```


If you have problems, there are more details about installing `terra` [here](https://rspatial.github.io/terra/index.html) and `sf` [here](https://r-spatial.github.io/sf/#installing).  

We can now load the packages:

```{r}
#| message: false

library(dplyr)
library(terra)
library(sf)
```

# Spatial data

There are basically two types of spatial data: vector and raster

## Vector data 
Can be points, lines or polygons. Vectors are useful for representing things like survey locations, rivers, and boundaries. 

```{r}
#| code-fold: true

pts <- rbind(c(3.2,4), c(3,4.6), c(3.8,4.4), c(3.5,3.8), c(3.4,3.6), c(3.9,4.5)) |>
  vect()

lnes <- as.lines(vect(rbind(c(3,4.6), c(3.2,4), c(3.5,3.8)))) |>
  rbind(as.lines(vect(rbind(c(3.9, 4.5), c(3.8, 4.4), c(3.5,3.8), c(3.4,3.6)))))

lux <- vect(system.file("ex/lux.shp", package = "terra"))

par(mfrow = c(1,3))

plot(pts, axes = F, main = "Points")
plot(lnes, col = "blue", axes = F, main = "Lines")
plot(lux, "NAME_2", col = terrain.colors(12), las = 1, axes = F, main = "Polygons")

```

## Raster data 
Raster data is a grid of rectangles, normally called cells. Each cell has a value, making rasters useful for storing continuous data, such as temperature and elevation.

Here is an example of raster data, where each cell in the raster represents elevation.

```{r}
#| code-fold: true

par(mfrow = c(1,1))

elev <- system.file("ex/elev.tif", package = "terra") |>
  rast() |>
  aggregate(fact = 2)

plot(elev, las = 1, main = "Elevation map")

elev |>
  as.polygons(aggregate = FALSE, na.rm = FALSE) |>
  lines(col = "grey40", lwd = 0.2)

```

# Getting started

## Making and inspecting a raster

Lets start by creating our own raster. We will be doing all manipulation of rasters with the `terra` package. To create rasters from scratch or load them from a file we use the function `rast()`. We can create a simple raster by specifying the x and y limits for the raster and the resolution (how big each cell is).


```{r}
#create raster
ras <- rast(xmin = 0, xmax = 10, ymin = 0, ymax = 10, resolution = 2)

#see what we've created
ras
```

The figure below shows what most of the terms above refer to. As you can see, you don't need to use all the terms to define a raster. Some other important points to note:

- Every object in R has a class, such as `data.frame` and as you can see, rasters in terra are of class `SpatRaster`. 
- We did not tell `rast()` which coordinate reference system to use, so it defaults to using longitude latitude coordinates, also known as EPSG 4326. We will come back to coordinate reference systems later.

```{r}
#| echo: false

knitr::include_graphics("figs/terra_raster_properties_figure.png")
```

But what does the raster we created actually look like when plotted. Lets see. All we need is `plot()`

```{r}
#| fig-width: 3

plot(ras)
```

Why is there no plot? Because the raster we created is empty; there are no values associated with the the cells. Lets assign some values to each cell in the raster and try again. First we will find out how many cells are in our raster using `ncell()

```{r}
ncell(ras)
```

Ok, now we know this lets give our raster cells values from 1 to `r ncell(ras)`:

```{r}
values(ras) <- 1:25

plot(ras)
```

Now our raster has values, we get a plot! Each cell has an integer value between 1 and 25, with cell values increasing from left to right and top to bottom. So the values start being "filled up" in the top left, and finish in the bottom right.

Lets have another look at our raster properties

```{r}
ras
```

We can now see a few extra pieces of information compared to last time:

- `sources(s)`: where is the data held on your computer? It says `memory` for this raster, indicating that the raster is in the computer memory. Rasters can also be held on your hard disk, in which case this will be the file name of the raster. We won't go into details here, but `terra` is smart about loading data into memory, only doing so when it needs to and it thinks it will have enough space.
- `name`: what is the raster called?
- `min value` & `max value`: the minimum and maximum values in the raster

Ok, now we understand the basic structure of a raster, lets look at vector data using the `sf` package.

## Making and inspecting a vector

As mentioned earlier, vector data can be points, lines or polygons. Let's start by making a single spatial point and plot it:

```{r}
pt <- st_point(c(1,3))

plot(pt, axes = TRUE)
```

Simple! But this is just a point. What if we want our point to have some information attached to it? For example, what the temperature is at that point. Well first we need to convert it into a simple feature collection:

```{r}
pt_sf <- pt |> 
  st_sfc() |> 
  st_as_sf()

pt_sf
```

Inspecting the simple feature collection, `pt_sf`, that we created, we see that there is only 1 feature; our point. There is also a bounding box, which is the same concept as the x and y limits we had for our raster. Like the raster, we also have coordinate reference system (CRS), that is currently not defined.

Now our point is a simple feature collection, we can add some information to it. We will add a column called "temperature" and give our point a value of 25.

```{r}
pt_sf$temperature <- 25

pt_sf
```

Now our point has a "field" attached to it with temperature data. The fields are simply columns that have information for each geometry; in our case a point. 

# Real world data

## Vectors

### Loading and plotting

Most of the time, we won't be making our own data from scratch, but reading in data that we have downloaded or been provided with. In this workshop, you are going to be doing a case study of Koalas in south-east Queensland (SEQ). One of the first pieces of spatial data we normally need are the boundaries of the area we are working in. We will use spatial data of the local government areas (LGAs) in Queensland downloaded from the Queensland government [website](https://qldspatial.information.qld.gov.au/catalogue/custom/detail.page?fid={3F3DBD69-647B-4833-B0A5-CC43D5E70699}) to define our SEQ boundary. 

We use `st_read()` to read the data which is in the `data` folder you should have downloaded with the code from Github. The file is a Geopackage, which is widely used for storing geospatial data, and is similar (but better!) than shapefile. The `st_read()` command can read data in many different spatial formats: run `st_drivers()` to see a complete list of formats.

```{r}
#| warning: false

lgas <- st_read("data/Local_Goverment_Areas.gpkg")
```

`sf` gives us some information about the data we have read: we can see it is MULTIPOLYGON and has 78 features and 6 fields, i.e. 78 rows of geometry and 6 columns of data. Lets have a look at the first few rows (features):

```{r}
head(lgas)
```

Now we can see that the 6 fields contain information about each LGA, including various name formats and the areas. The final column called "Shape" contains the spatial information: the coordinates for each point that makes up the polygons. This column is most commonly labelled "geometry".

The fields in our `sf` data are just like columns in a data frame. So if we want all the values in one column, we can just select that column in the same way as a data frame:

```{r}
lgas$lga
```

Remember that the CRS of our data is GDA94. What does this mean? We can get some more information using `st_crs()`:

```{r}
st_crs(lgas)
```

The "wkt", well-known text, gives a lot of detail, but we can see that this is a CRS that is specific to Australia. 

Let's plot the data to see what we have:

```{r}
plot(lgas)
```

Looks like Queensland! We got one map for each field (column). If we want a map of just one field we can select only the field we want:

```{r}
plot(lgas[, "lga"], axes = TRUE)
```

We added axes using the `axes = TRUE` argument. 

### Subsetting

We have LGAs for the whole of Queensland, but we just want a polygon of south-east Queensland (SEQ). How do we get that?

First, we make a vector containing the names of all the LGAs in SEQ:

```{r}
seq_lga_names <- c(
  "Brisbane City",
  "Moreton Bay City",
  "Logan City",
  "Ipswich City",
  "Redland City",
  "Scenic Rim Regional",
  "Somerset Regional",
  "Lockyer Valley Regional",
  "Gold Coast City",
  "Sunshine Coast Regional",
  "Toowoomba Regional",
  "Noosa Shire"
)
```

Now we can subset our LGAs spatial data for just these LGAs:

```{r}
lgas_seq <- lgas |> 
  filter(lga %in% seq_lga_names)

plot(lgas_seq[, "lga"])
```

Great! We've got only the LGAs in SEQ. But at the moment we have many polygons that make up SEQ:

```{r}
head(lgas_seq)
```

How do we get just one polygon that is the boundary of the area? We use `st_union()`:

```{r}
seq_boundary <- st_union(lgas_seq)

plot(seq_boundary)
```

This merges all our polygons into one polygon. Note that we lose all the fields when we do this:

```{r}
head(seq_boundary)
```

### Saving

We will need the SEQ polygon later, so lets save it using `st_write()`:

```{r}
st_write(seq_boundary, "data/seq_polygon.gpkg")
```

You can save in many different formats (see `st_drivers()`). You can change the file format just by changing the file extension, e.g. use "seq_polygon.shp" if you want a shapefile.

TO DO: Projection before saving. Might be easiest to have the original lgas object in 4326 and then project since that's easier to understand and more common. 

```{r}

```

