---
title: "Getting started with geospatial coding in R using the terra and sf packages"
author: "Jason Flower"
date: "`r Sys.Date()`"
toc: true
number-sections: false
format: 
  html:
    self-contained: true
    code-tools: true
    df-print: paged
    fig-width: 6
abstract: |
  This is the first session of the ICCB workshop titled "Open Source Geospatial Tools for Conservation under Climate Change - a Koala Case Study". We will provide an introduction to working with geospatial in R using the sf and terra packages.
---

No prior experience of spatial data is assumed, but this introduction will not have time to delve deeply into some important aspects of spatial data such as projections. We will use the two most commonly used R packages for geospatial data manipulation: `sf` for manipulating vector data, and `terra` for manipulating raster and vector data. If you are still using the `raster` package, you should move to `terra`; it is simpler, faster and can do more!

*Resources*:

- The official `terra` [tutorial page](https://rspatial.org/spatial/index.html), and [reference](https://rspatial.github.io/terra/reference/terra-package.html) to all the `terra` functions
- The official `sf` [website](https://r-spatial.github.io/sf/) with a wealth of tutorials, function documentation, and further links
- The excellent Geocomputation with R [book](https://r.geocompx.org) which uses both `sf` and `terra`
- [This website](https://mgimond.github.io/Spatial/index.html) is a good guide to doing GIS work in R using both `terra` and `sf` packages

## Prerequisites 

You will need the `terra` and `sf` packages installed. We will also make an interactive map with `terra`, which requires the `leaflet` package to be installed, and we will need the `dplyr` package for data manipulation. 

```{r}
#| eval: false

install.packages(c("sf", "terra", "leaflet", "dplyr"))
```


If you have problems, there are more details about installing `terra` [here](https://rspatial.github.io/terra/index.html) and `sf` [here](https://r-spatial.github.io/sf/#installing).  

We can now load the packages:

```{r}
#| message: false

library(dplyr)
library(terra)
library(sf)
```

# Spatial data

There are basically two types of spatial data: vector and raster

## Vector data 
Can be points, lines or polygons. Useful for representing things like survey locations, rivers, and boundaries. 

```{r}
#| code-fold: true

pts <- rbind(c(3.2,4), c(3,4.6), c(3.8,4.4), c(3.5,3.8), c(3.4,3.6), c(3.9,4.5)) |>
  vect()

lnes <- as.lines(vect(rbind(c(3,4.6), c(3.2,4), c(3.5,3.8)))) |>
  rbind(as.lines(vect(rbind(c(3.9, 4.5), c(3.8, 4.4), c(3.5,3.8), c(3.4,3.6)))))

lux <- vect(system.file("ex/lux.shp", package = "terra"))

par(mfrow = c(1,3))

plot(pts, axes = F, main = "Points")
plot(lnes, col = "blue", axes = F, main = "Lines")
plot(lux, "NAME_2", col = terrain.colors(12), las = 1, axes = F, main = "Polygons")

```

## Raster data 
Raster data is a grid of rectangles, normally called cells. Each cell has a value, making rasters useful for storing continuous data, such as temperature and elevation.

Here is an example of raster data, where each cell in the raster represents elevation.

```{r}
#| code-fold: true

par(mfrow = c(1,1))

elev <- system.file("ex/elev.tif", package = "terra") |>
  rast() |>
  aggregate(fact = 2)

plot(elev, las = 1, main = "Elevation map")

elev |>
  as.polygons(aggregate = FALSE, na.rm = FALSE) |>
  lines(col = "grey40", lwd = 0.2)

```

# Getting started

## Making and inspecting a raster

Lets start by creating our own raster. We can create rasters from scratch or load them from a file using the `terra` function `rast()`. We can create a simple raster by specifying the x and y limits for the raster and the resolution (how big each cell is).


```{r}
#create raster
ras <- rast(xmin = 0, xmax = 10, ymin = 0, ymax = 10, resolution = 2)

#see what we've created
ras
```

The figure below shows what most of the terms above refer to. As you can see, you don't need to use all the terms to define a raster. Some other important points to note:

- Every object in R has a class, such as `data.frame` and as you can see, rasters in terra are of class `SpatRaster`. 
- We did not tell `rast()` which coordinate reference system to use, so it defaults to using longitude latitude coordinates, also known as EPSG 4326. We will come back to coordinate reference systems later.

```{r}
#| echo: false

knitr::include_graphics("figs/terra_raster_properties_figure.png")
```

But what does the raster we created actually look like when plotted. Lets see. All we need is `plot()`

```{r}
#| fig-width: 3

plot(ras)
```

Why is there no plot? Because the raster we created is empty; there are no values associated with the the cells. Lets assign some values to each cell in the raster and try again. First we will find out how many cells are in our raster using `ncell()

```{r}
ncell(ras)
```

Ok, now we know this lets give our raster cells values from 1 to `r ncell(ras)`:

```{r}
values(ras) <- 1:25

plot(ras)
```

Now our raster has values, we get a plot! Each cell has an integer value between 1 and 25, with cell values increasing from left to right and top to bottom. So the values start being "filled up" in the top left, and finish in the bottom right.

Lets have another look at our raster properties

```{r}
ras
```

We can now see a few extra pieces of information compared to last time:

- `sources(s)`: where is the data held on your computer? It says `memory` for this raster, indicating that the raster is in the computer memory. Rasters can also be held on your hard disk, in which case this will be the file name of the raster. We won't go into details here, but `terra` is smart about loading data into memory, only doing so when it needs to and it thinks it will have enough space.
- `name`: what is the raster called?
- `min value` & `max value`: the minimum and maximum values in the raster

Ok, now we understand the basic structure of a raster, lets look at vector data using the `sf` package.

## Making and inspecting a vector

As mentioned earlier, vector data can be points, lines or polygons. Let's start by making a single spatial point and plot it:

```{r}
pt <- st_point(c(1,3))

plot(pt, axes = TRUE)
```

Simple! But this is just a point. What if we want our point to have some information attached to it? For example, what the temperature is at that point. Well first we need to convert it into a simple feature collection:

```{r}
pt_sf <- pt |> 
  st_sfc() |> 
  st_as_sf()

pt_sf
```

Inspecting the simple feature point, `pt_sf`, that we created, we see that there is only 1 feature; our point. There is also a bounding box, which is the same concept as the x and y limits we had for our raster. Like the raster, we also have coordinate reference system (CRS), that is currently not defined.

Now our point is a simple feature collection, we can add some information to it. We will add a column called "temperature" and give our point a value of 25.

```{r}
pt_sf$temperature <- 25

pt_sf
```

Now our point has a "field" attached to it with temperature data. The fields are simply columns that have information for each geometry; in our case a point. 

# Real world data

Most of the time, we won't be making our own data from scratch, but reading in data that we have downloaded or been provided with. In this workshop, you are going to be doing a case study of Koalas in south-east Queensland (SEQ). One of the first pieces of spatial data we normally need are the boundaries of the area we are working in. We will use spatial data of the local government areas in Queensland downloaded from the Queensland government [website](https://qldspatial.information.qld.gov.au/catalogue/custom/detail.page?fid={3F3DBD69-647B-4833-B0A5-CC43D5E70699}) to define our SEQ boundary. 

We use `st_read()` to read the data which is in the `data` folder you should have downloaded with the code from Github. The file is a Geopackage, which is widely used for storing geospatial data, and is similar (but better!) than shapefile. The `st_read()` command can read data in many different spatial formats: run `st_drivers()` to see a complete list of formats.

```{r}
lgas <- st_read("data/Local_Goverment_Areas.gpkg")
```

`sf` gives us some information about the data we have read: we can see it is MULTIPOLYGON and has 78 features and 6 fields. 
